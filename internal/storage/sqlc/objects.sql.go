// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: objects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkObjectExistsOnBackend = `-- name: CheckObjectExistsOnBackend :one
SELECT EXISTS(
    SELECT 1 FROM object_locations
    WHERE object_key = $1 AND backend_name = $2
) AS exists
`

type CheckObjectExistsOnBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) CheckObjectExistsOnBackend(ctx context.Context, arg CheckObjectExistsOnBackendParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkObjectExistsOnBackend, arg.ObjectKey, arg.BackendName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteObjectCopies = `-- name: DeleteObjectCopies :exec
DELETE FROM object_locations
WHERE object_key = $1
`

func (q *Queries) DeleteObjectCopies(ctx context.Context, objectKey string) error {
	_, err := q.db.Exec(ctx, deleteObjectCopies, objectKey)
	return err
}

const deleteObjectFromBackend = `-- name: DeleteObjectFromBackend :exec
DELETE FROM object_locations
WHERE object_key = $1 AND backend_name = $2
`

type DeleteObjectFromBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) DeleteObjectFromBackend(ctx context.Context, arg DeleteObjectFromBackendParams) error {
	_, err := q.db.Exec(ctx, deleteObjectFromBackend, arg.ObjectKey, arg.BackendName)
	return err
}

const getAllObjectLocations = `-- name: GetAllObjectLocations :many
SELECT object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key = $1
ORDER BY created_at ASC
`

func (q *Queries) GetAllObjectLocations(ctx context.Context, objectKey string) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, getAllObjectLocations, objectKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectoryStats = `-- name: GetDirectoryStats :many
SELECT
    (CASE WHEN position('/' IN substring(object_key FROM length($1::text) + 1)) > 0
         THEN substring(object_key FROM length($1::text) + 1
              FOR position('/' IN substring(object_key FROM length($1::text) + 1)))
         ELSE substring(object_key FROM length($1::text) + 1)
    END)::text AS name,
    (CASE WHEN position('/' IN substring(object_key FROM length($1::text) + 1)) > 0
         THEN true ELSE false
    END)::boolean AS is_dir,
    COUNT(DISTINCT object_key)  AS file_count,
    COALESCE(SUM(size_bytes), 0)::bigint AS total_size
FROM object_locations
WHERE object_key LIKE $1::text || '%' ESCAPE '\'
  AND length(object_key) > length($1::text)
GROUP BY name, is_dir
ORDER BY is_dir DESC, name ASC
`

type GetDirectoryStatsRow struct {
	Name      string
	IsDir     bool
	FileCount int64
	TotalSize int64
}

// Aggregate count and size for immediate children of a directory prefix.
// Directories (containing a '/') and files are distinguished by is_dir.
func (q *Queries) GetDirectoryStats(ctx context.Context, prefix string) ([]GetDirectoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getDirectoryStats, prefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDirectoryStatsRow{}
	for rows.Next() {
		var i GetDirectoryStatsRow
		if err := rows.Scan(
			&i.Name,
			&i.IsDir,
			&i.FileCount,
			&i.TotalSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingCopiesForUpdate = `-- name: GetExistingCopiesForUpdate :many
SELECT backend_name, size_bytes
FROM object_locations
WHERE object_key = $1
FOR UPDATE
`

type GetExistingCopiesForUpdateRow struct {
	BackendName string
	SizeBytes   int64
}

func (q *Queries) GetExistingCopiesForUpdate(ctx context.Context, objectKey string) ([]GetExistingCopiesForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getExistingCopiesForUpdate, objectKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExistingCopiesForUpdateRow{}
	for rows.Next() {
		var i GetExistingCopiesForUpdateRow
		if err := rows.Scan(&i.BackendName, &i.SizeBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertObjectLocation = `-- name: InsertObjectLocation :exec
INSERT INTO object_locations (object_key, backend_name, size_bytes, created_at)
VALUES ($1, $2, $3, NOW())
`

type InsertObjectLocationParams struct {
	ObjectKey   string
	BackendName string
	SizeBytes   int64
}

func (q *Queries) InsertObjectLocation(ctx context.Context, arg InsertObjectLocationParams) error {
	_, err := q.db.Exec(ctx, insertObjectLocation, arg.ObjectKey, arg.BackendName, arg.SizeBytes)
	return err
}

const insertObjectLocationIfNotExists = `-- name: InsertObjectLocationIfNotExists :one
INSERT INTO object_locations (object_key, backend_name, size_bytes, created_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (object_key, backend_name) DO NOTHING
RETURNING true AS inserted
`

type InsertObjectLocationIfNotExistsParams struct {
	ObjectKey   string
	BackendName string
	SizeBytes   int64
}

func (q *Queries) InsertObjectLocationIfNotExists(ctx context.Context, arg InsertObjectLocationIfNotExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, insertObjectLocationIfNotExists, arg.ObjectKey, arg.BackendName, arg.SizeBytes)
	var inserted bool
	err := row.Scan(&inserted)
	return inserted, err
}

const listDirectChildren = `-- name: ListDirectChildren :many
SELECT DISTINCT ON (object_key) object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key LIKE $1::text || '%' ESCAPE '\'
  AND position('/' IN substring(object_key FROM length($1::text) + 1)) = 0
  AND length(object_key) > length($1::text)
  AND object_key > $2
ORDER BY object_key, created_at ASC
LIMIT $3
`

type ListDirectChildrenParams struct {
	Prefix     string
	StartAfter string
	MaxKeys    int32
}

// Return per-file detail for non-directory children under a prefix, with pagination.
func (q *Queries) ListDirectChildren(ctx context.Context, arg ListDirectChildrenParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listDirectChildren, arg.Prefix, arg.StartAfter, arg.MaxKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredObjects = `-- name: ListExpiredObjects :many
SELECT DISTINCT ON (object_key) object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key LIKE $1::text || '%' ESCAPE '\'
  AND created_at < $2
ORDER BY object_key, created_at ASC
LIMIT $3
`

type ListExpiredObjectsParams struct {
	Prefix  string
	Cutoff  pgtype.Timestamptz
	MaxKeys int32
}

func (q *Queries) ListExpiredObjects(ctx context.Context, arg ListExpiredObjectsParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listExpiredObjects, arg.Prefix, arg.Cutoff, arg.MaxKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByBackend = `-- name: ListObjectsByBackend :many
SELECT object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE backend_name = $1
ORDER BY size_bytes ASC
LIMIT $2
`

type ListObjectsByBackendParams struct {
	BackendName string
	Limit       int32
}

func (q *Queries) ListObjectsByBackend(ctx context.Context, arg ListObjectsByBackendParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listObjectsByBackend, arg.BackendName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObjectsByPrefix = `-- name: ListObjectsByPrefix :many
SELECT DISTINCT ON (object_key) object_key, backend_name, size_bytes, created_at
FROM object_locations
WHERE object_key LIKE $1::text || '%' ESCAPE '\'
  AND object_key > $2
ORDER BY object_key, created_at ASC
LIMIT $3
`

type ListObjectsByPrefixParams struct {
	Prefix     string
	StartAfter string
	MaxKeys    int32
}

func (q *Queries) ListObjectsByPrefix(ctx context.Context, arg ListObjectsByPrefixParams) ([]ObjectLocation, error) {
	rows, err := q.db.Query(ctx, listObjectsByPrefix, arg.Prefix, arg.StartAfter, arg.MaxKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ObjectLocation{}
	for rows.Next() {
		var i ObjectLocation
		if err := rows.Scan(
			&i.ObjectKey,
			&i.BackendName,
			&i.SizeBytes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockObjectOnBackend = `-- name: LockObjectOnBackend :one
SELECT size_bytes
FROM object_locations
WHERE object_key = $1 AND backend_name = $2
FOR UPDATE
`

type LockObjectOnBackendParams struct {
	ObjectKey   string
	BackendName string
}

func (q *Queries) LockObjectOnBackend(ctx context.Context, arg LockObjectOnBackendParams) (int64, error) {
	row := q.db.QueryRow(ctx, lockObjectOnBackend, arg.ObjectKey, arg.BackendName)
	var size_bytes int64
	err := row.Scan(&size_bytes)
	return size_bytes, err
}
